
import java.util.Random;
import java.util.Scanner;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author windows
 */
public class ExamScheduler extends javax.swing.JFrame {
    
    
    int generation;
    int popSize;
    int numStudents;
    int totalModuleNum;
    int courseModuleNum;
    int numSessions;
    int crossoverProb;
    int mutationProb;
    int reproductionProb;
    int toGen = 0;
    int [][] studentsSchedule;
    int[][] orderingPopulations;
    int [] fitnessArray;
    int[] GAProbArray;
    int GACount;
    boolean [] markedOrderings;
    
    /**
     * Creates new form InputForm
     */
    public ExamScheduler() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        titleLbl = new javax.swing.JLabel();
        genTxt = new javax.swing.JTextField();
        popTxt = new javax.swing.JTextField();
        studentNumTxt = new javax.swing.JTextField();
        totalModNumTxt = new javax.swing.JTextField();
        examSessionsTxt = new javax.swing.JTextField();
        crossoverProbTxt = new javax.swing.JTextField();
        mutationProbTxt = new javax.swing.JTextField();
        courseModNumTxt = new javax.swing.JTextField();
        genLabel = new javax.swing.JLabel();
        popLbl = new javax.swing.JLabel();
        studentNumLbl = new javax.swing.JLabel();
        totalModNumLbl = new javax.swing.JLabel();
        examSessionsLbl = new javax.swing.JLabel();
        crossoverProbLbl = new javax.swing.JLabel();
        courseModNumLbl = new javax.swing.JLabel();
        mutationProbLbl = new javax.swing.JLabel();
        okBtn = new javax.swing.JButton();
        warningLbl = new javax.swing.JLabel();
        warningLbl2 = new javax.swing.JLabel();
        reproductionProbTxt = new javax.swing.JTextField();
        reproductionProbLbl = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        titleLbl.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        titleLbl.setText("Input the parameters for the exam schedule below");

        genTxt.setText("100");

        popTxt.setText("20");

        studentNumTxt.setText("50");

        totalModNumTxt.setText("50");

        examSessionsTxt.setText("9");

        crossoverProbTxt.setText("25");

        mutationProbTxt.setText("25");

        courseModNumTxt.setText("6");

        genLabel.setText("Generations");

        popLbl.setText("Population Size");

        studentNumLbl.setText("Number of Students");

        totalModNumLbl.setText("Total number of Modules");

        examSessionsLbl.setText("Number of Exam Sessions/Days");

        crossoverProbLbl.setText("Crossover Possibility");

        courseModNumLbl.setText("Number of Modules in Course");

        mutationProbLbl.setText("Mutation Probability");

        okBtn.setText("OK");
        okBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                okBtnActionPerformed(evt);
            }
        });

        warningLbl.setForeground(new java.awt.Color(255, 0, 0));

        warningLbl2.setForeground(new java.awt.Color(255, 0, 0));

        reproductionProbTxt.setText("50");

        reproductionProbLbl.setText("Reproduction Probability");

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(okBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 147, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(113, 113, 113))
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGap(37, 37, 37)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(mutationProbTxt, javax.swing.GroupLayout.PREFERRED_SIZE, 309, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(examSessionsTxt, javax.swing.GroupLayout.PREFERRED_SIZE, 309, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(totalModNumTxt, javax.swing.GroupLayout.PREFERRED_SIZE, 309, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(mutationProbLbl)
                            .addComponent(totalModNumLbl)
                            .addComponent(crossoverProbLbl)
                            .addComponent(courseModNumTxt, javax.swing.GroupLayout.PREFERRED_SIZE, 309, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(studentNumLbl)
                            .addComponent(popLbl)
                            .addComponent(genLabel)
                            .addComponent(crossoverProbTxt, javax.swing.GroupLayout.PREFERRED_SIZE, 309, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(popTxt, javax.swing.GroupLayout.PREFERRED_SIZE, 309, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(genTxt, javax.swing.GroupLayout.PREFERRED_SIZE, 309, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(studentNumTxt, javax.swing.GroupLayout.PREFERRED_SIZE, 309, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(courseModNumLbl)
                            .addComponent(examSessionsLbl)
                            .addComponent(titleLbl, javax.swing.GroupLayout.PREFERRED_SIZE, 377, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(warningLbl, javax.swing.GroupLayout.PREFERRED_SIZE, 91, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(warningLbl2)))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(reproductionProbLbl)
                            .addComponent(reproductionProbTxt, javax.swing.GroupLayout.PREFERRED_SIZE, 309, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addComponent(titleLbl)
                .addGap(22, 22, 22)
                .addComponent(genLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(genTxt, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(popLbl)
                        .addGap(4, 4, 4)
                        .addComponent(popTxt, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(2, 2, 2)
                        .addComponent(studentNumLbl))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(3, 3, 3)
                        .addComponent(warningLbl, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(studentNumTxt, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(totalModNumLbl)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(totalModNumTxt, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(9, 9, 9)
                .addComponent(courseModNumLbl)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(courseModNumTxt, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(examSessionsLbl)
                    .addComponent(warningLbl2))
                .addGap(4, 4, 4)
                .addComponent(examSessionsTxt, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(crossoverProbLbl)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(crossoverProbTxt, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(mutationProbLbl)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(mutationProbTxt, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(reproductionProbLbl)
                .addGap(10, 10, 10)
                .addComponent(reproductionProbTxt, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 48, Short.MAX_VALUE)
                .addComponent(okBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 35, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void okBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_okBtnActionPerformed
        if(genTxt.getText().length()<1||popTxt.getText().length()<1||studentNumTxt.getText().length()<1||
                totalModNumTxt.getText().length()<1||courseModNumTxt.getText().length()<1||examSessionsTxt.getText().length()<1||
                crossoverProbTxt.getText().length()<1||mutationProbTxt.getText().length()<1){
            
            warningLbl.setText("<html>All fields must be filled<html>");
            return;
        }
       
        //If all of the input fields are filled, then parse them into int variables
        try{
            generation = Integer.parseInt(genTxt.getText().trim());
            popSize = Integer.parseInt(popTxt.getText().trim());
            numStudents = Integer.parseInt(studentNumTxt.getText().trim());
            totalModuleNum = Integer.parseInt(totalModNumTxt.getText().trim());
            courseModuleNum = Integer.parseInt(courseModNumTxt.getText().trim());
            numSessions = Integer.parseInt(examSessionsTxt.getText().trim());
            crossoverProb = Integer.parseInt(crossoverProbTxt.getText().trim());
            mutationProb = Integer.parseInt(mutationProbTxt.getText().trim());
            reproductionProb = Integer.parseInt(reproductionProbTxt.getText().trim());
        }catch(NumberFormatException e){
            warningLbl.setText("<html>Part of input is not an integer <html>");
            return;
        }
        
        
        if((crossoverProb+reproductionProb+mutationProb)!=100){
             warningLbl.setText("<html>Crossover, mutation, and reproduction probabilities must"
                     + "sum to 100 <html>");
            return;
        }
         /*
        Code below checks that the user-provided population number does not
        exceed the factorial of the total number of modules. If this check was not performed, then the 
        program would loop endlessly later on as it tried to fix identical orderings
        that would inevitably keep recurring in the ordering population array
        */
      
        double modPermutations=totalModuleNum; 
        /*
        modPermutations' value is initially set to the value of totalMod, then, through the course of 
        the for loop, it is multiplied against a sequentially decremented value of i, corresponding at each
        iteration to modPermutations minus one. In this way the factorial of totalMod can be calculated
        */
        for(int i =totalModuleNum-1; i>1; i--){
            modPermutations = modPermutations*i;
        }
        if(popSize>modPermutations){
            warningLbl.setText("<html> Population number cannot exceed factorial of total number of modules <html>");
            return;
        }
        //If there are any zero values, warn the user and prompt new input
        if(generation<1||popSize<1||numStudents<1||totalModuleNum<1||courseModuleNum<1
                ||numSessions<1||crossoverProb<1||mutationProb<1){
            
            warningLbl.setText("<html>Parameters' values must be greater than zero <html>");
            return;
        }else if(courseModuleNum>totalModuleNum){
            warningLbl.setText("<html>Number of course modules cannot exceed total number of modules <html>");
            return;
        }
        /*Array holding values corresponding to each GA tecnique. The higher the probabiity of a GA technique, the more space
        it gets in the array*/
        int count =0;
        GAProbArray = new int[100];
        for(int i=0; i<crossoverProb; i++){
            GAProbArray[count]=1;
            count++;
        }
        for(int i=0; i<mutationProb; i++){
            GAProbArray[count]=2;
            count++;
        }
        for(int i=0; i<reproductionProb; i++){
            GAProbArray[count]=3;
            count++;
        }
        
        
        //Call the method to create the student schedule
        studentsSchedule = createStudentsSchedule(numStudents, courseModuleNum, totalModuleNum);

        //Print out the values in each student schedule
        for(int i = 0; i< numStudents; i++){
            System.out.print("Student "+(i+1)+": ");

            for(int j =0;j<courseModuleNum;j++){
                System.out.print(studentsSchedule[i][j]+" ");
            }
            System.out.print("\n"); 
        }

        System.out.println("\n");
        System.out.println("Waiting for the end-user Enter to continue");
        while(true){
            Scanner sc = new Scanner(System.in);
            if (sc.nextLine().equals("")){
                break; 
            }  
        }
        System.out.println("\nPopulation \n \n");
        
       

        //Call method to create ordering populations
        orderingPopulations = createOrderingPopulation(popSize, totalModuleNum);

        //Boolean to keep while loop running while there exists identical orderings in the population
        boolean orderingCheckFlag = true;

        while(orderingCheckFlag==true){
            int identicalElementLocation = isOrderingValid(orderingPopulations, popSize);
            if(identicalElementLocation>=0){
                orderingPopulations = editOrderingPopulation(orderingPopulations, popSize, identicalElementLocation, totalModuleNum);
                //System.out.println("Orderings repeated, need edit");
            }
            else if(identicalElementLocation<0){
                orderingCheckFlag = false;
                //System.out.println("Orderings fine");
            }
        }
        fitnessArray = new int[popSize];
        for(int i = 0; i<popSize; i++){
           int[] orderingPop = new int[totalModuleNum];
           System.arraycopy(orderingPopulations[i], 0, orderingPop, 0, orderingPop.length);
           fitnessArray[i]= gaugeFitness(orderingPop, studentsSchedule, totalModuleNum, numSessions, numStudents, courseModuleNum);
        }






        for(int i=0; i<popSize; i++){
            System.out.print("Ordering "+ (i+1) + ":  ");
           for(int j =0;j<totalModuleNum;j++){
                    System.out.print(orderingPopulations[i][j]+" ");
           }
           System.out.print(": Fitness cost: "+ fitnessArray[i]); 
           System.out.print("\n"); 
        }
            
        System.out.print("\n");
        System.out.print("\n");
        System.out.print("\n");
        System.out.print("ORIGINAL GENERATION OVER---------------");
        System.out.print("\n");
        System.out.print("\n");
        System.out.print("\n");

        toGen++;
        //While loop running until the number of generations specified by user is reached
        while (toGen < generation) {
            //Perform selection on the orderings
           fitnessArray = performSelection(fitnessArray);
            
           //Perform GA techniques on the orderings
           markedOrderings = new boolean[popSize];
           for(GACount=0; GACount<popSize; GACount++){
                Random rand = new Random();
                int randInt = rand.nextInt(100);
                if (GAProbArray[randInt] == 1) {
                    orderingPopulations = performCrossover(orderingPopulations);
                } else if (GAProbArray[randInt] == 2) {
                    orderingPopulations = performMutation(orderingPopulations);
                } else if (GAProbArray[randInt] == 3) {
                    orderingPopulations = performReproduction(orderingPopulations);
                }
            }
            for (int i = 0; i < popSize; i++) {
                int[] orderingPop = new int[totalModuleNum];
                System.arraycopy(orderingPopulations[i], 0, orderingPop, 0, orderingPop.length);
                fitnessArray[i] = gaugeFitness(orderingPop, studentsSchedule, totalModuleNum, numSessions, numStudents, courseModuleNum);
            }

            fitnessArray = sortOrderings(fitnessArray);
            

            int bestOrderLoc = findBestOrdering(fitnessArray);
            int[] bestOrdering = orderingPopulations[bestOrderLoc];
            int modulesInSession = totalModuleNum / numSessions;

            if (totalModuleNum % numSessions != 0) {
                modulesInSession = modulesInSession + 1;
            }

            int[][] sessions = new int[numSessions][modulesInSession];
            int orderingPopCount = 0;
            for (int i = 0; i < numSessions; i++) {
                for (int j = 0; j < modulesInSession; j++) {
                    if (orderingPopCount > (bestOrdering.length) - 1) {
                        break;
                    }
                    sessions[i][j] = bestOrdering[orderingPopCount];

                    orderingPopCount++;
                }
            }

            System.out.println("");
            System.out.println("Generation: " + toGen);
            System.out.print("Ordering: ");
            for (int i = 0; i < bestOrdering.length; i++) {
                System.out.print(bestOrdering[i] + " ");
            }
            System.out.println(" ");
            for (int i = 1; i <= numSessions; i++) {
                System.out.print("Session  " + i);
                System.out.print("       ");
            }
            System.out.println("");

            for (int j = 0; j < modulesInSession; j++) {
                for (int i = 0; i < numSessions; i++) {
                    if (sessions[i][j] == 0) {
                        System.out.format("%5s", "");
                    } else {
                        System.out.format("%5d", sessions[i][j]);
                    }
                    System.out.print("            ");

                }
                System.out.println(" ");
            }

            System.out.println("Fitness Cost: " + fitnessArray[bestOrderLoc]);
            System.out.println("------------------------------------------------------------------");
            toGen++;
        }


    }//GEN-LAST:event_okBtnActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(ExamScheduler.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(ExamScheduler.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(ExamScheduler.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(ExamScheduler.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new ExamScheduler().setVisible(true);
            }
        });
    }
    
    private static int[][] createStudentsSchedule(int numStudents, int courseModuleNum, int totalModuleNum){
        //warningLbl2.setText(numStudents+ " ");
        
        int[][] studentsSchedule = new int[numStudents][courseModuleNum];
        
        Random rand = new Random();
        
        for(int i = 0; i<numStudents; i++){
            boolean sameFlag = true;
            for(int j = 0; j<courseModuleNum; j++){
                studentsSchedule[i][j] = rand.nextInt(totalModuleNum)+1;
                
             }
            while(sameFlag==true){
                int sameCount= 0;
                int total = courseModuleNum-1; 
                for(int k = 0; k<courseModuleNum; k++){
                    for(int l = total; l>k; l--){
                        if(studentsSchedule[i][k]==studentsSchedule[i][l]&&(k!=l)){
                            sameCount ++;
                            studentsSchedule[i][l]= rand.nextInt(totalModuleNum)+1;
                        }
                    }
                }
                if(sameCount<1){
                    sameFlag = false;
                }else if(sameCount>0){
                    sameFlag = true;                  
                }
            }
        }
            
        
        
        return studentsSchedule;
    }
    
    
    
    public int[][] createOrderingPopulation(int population, int totalModuleNum){
        int[][] orderingPopulation = new int[population][totalModuleNum];
        
        Random rand = new Random();
        
        for(int i =0; i<population; i++){
            boolean sameFlag = true;
            for(int j=0; j<totalModuleNum; j++){
                orderingPopulation [i][j]= rand.nextInt((totalModuleNum))+1;
            }
             while(sameFlag==true){
                int sameCount= 0;
                int total = totalModuleNum-1; 
                for(int k = 0; k<totalModuleNum; k++){
                    for(int l = total; l>k; l--){
                        if(orderingPopulation[i][k]==orderingPopulation[i][l]&&(k!=l)){
                            sameCount ++;
                            orderingPopulation[i][l]= rand.nextInt(totalModuleNum)+1;
                            //System.out.println("rand int: "+ orderingPopulation[i][l]);
                        }
                    }
                }
                if(sameCount<1){
                    sameFlag = false;
                }else if(sameCount>0){
                    sameFlag = true;                  
                }
            }
        }
        
        return orderingPopulation;
    }
    
    public int isOrderingValid(int[][] orderingPopulation, int population ){
        /*
        Array will hold each ordering as a String of its constituent numbers 
        */
        String [] comparisonArray = new String [population];
        for(int i =0; i<population; i++){
            for(int j=0; j<totalModuleNum; j++){
                comparisonArray[i]+=orderingPopulation[i][j];
                //System.out.println(orderingPopulation[i][j]);
            }
            // System.out.print("\n \n");
        }
       
       
        /*
        Compare each ordering-String to every other in the array. 
        If there are any identical ordering-Strings, then there are clearly 
        identical orderings, and the location of the ordering that needs 
        to be changed is returned. Otherwise, if there are no identical
        orderings, -1 is returned
        */ 
        int location =-1;
        for(int i =0; i<population;i++){
            for(int j = (population-1);j>i; j-- ){
               
                if(comparisonArray[i].equals(comparisonArray[j])){
                    location =j;
                }
            }
        }
        
        return location;
    }
    
    
    
    public int[][] editOrderingPopulation(int[][] orderingPopulation, int population, int location, int totalModuleNum){
        Random rand = new Random();
        
       
            boolean sameFlag = true;
            for(int j=0; j<totalModuleNum; j++){
                orderingPopulation [location][j]= rand.nextInt(totalModuleNum)+1;
            }
             while(sameFlag==true){
                int sameCount= 0;
                int total = totalModuleNum-1; 
                for(int k = 0; k<totalModuleNum; k++){
                    for(int l = total; l>k; l--){
                        if(orderingPopulation[location][k]==orderingPopulation[location][l]&&(k!=l)){
                            sameCount ++;
                            orderingPopulation[location][l]= rand.nextInt(totalModuleNum)+1;
                        }
                    }
                }
                if(sameCount<1){
                    sameFlag = false;
                }else if(sameCount>0){
                    sameFlag = true;                  
                }
            }
        
        
        return orderingPopulation;
        
    }
    
    public int gaugeFitness(int[] orderingPop, int[][] studentsSchedule,
            int totalModuleNum, int numSessions, int numStudents, int courseModuleNum){ 
        
        int fitness =0;
        int modulesInSession = totalModuleNum/numSessions;      
        
        if(totalModuleNum%numSessions!=0){           
             modulesInSession = modulesInSession+1;
        }
        
        int[][] sessions = new int[numSessions][modulesInSession]; 
        int orderingPopCount =0;
        for(int i=0; i<numSessions; i++){
            for(int j=0; j<modulesInSession; j++){
                if(orderingPopCount>(orderingPop.length)-1){                  
                    break;
                }
                sessions[i][j] = orderingPop[orderingPopCount];
                
                orderingPopCount++;
            } 
        }
        
        int totalOverlaps=0;
        int modsInSession =0;
       
        for(int i=0; i<numSessions; i++){
            //
            for(int k=0; k<numStudents; k++){
                 modsInSession=0;
                for(int j=0; j<modulesInSession; j++){                    
                    for(int l = 0; l<courseModuleNum; l++){
                        if(sessions[i][j]==studentsSchedule[k][l]){
                            modsInSession ++;
                        }
                    }  
                }
                if(modsInSession>1){
                   totalOverlaps++;                 
                        
                }
            }
        }
        
        fitness = totalOverlaps;
        return fitness;
    }
    
    
    int[] performSelection(int [] fitnessArray){
        
         fitnessArray = sortOrderings(fitnessArray);
               //Perform selection on the orderingPopulations
                int divisor = popSize/3;
                int secondDivisor = divisor;
                if(popSize%3!=0){
                    divisor +=1;
                }
                int k=0;
                for(int i=(divisor+secondDivisor)-1; i<popSize; i++){               
                    for(int j= 0; j<totalModuleNum; j++){
                        orderingPopulations[i][j]=orderingPopulations[k][j];
                        fitnessArray[i]=fitnessArray[k];
                    }
                    k++;
                }
            
        
        return fitnessArray;
    }  
    
    int[] sortOrderings(int [] fitnessArray){
            int j;
            int temp;
            int [] tempOrd;
            for (int i = 1; i < fitnessArray.length; i++)
            {
                temp =fitnessArray[i];
                tempOrd = orderingPopulations[i];
                j = i-1;

                while (j >= 0 && fitnessArray[j] > temp)
                {
                    fitnessArray[j+1] = fitnessArray[j];
                    orderingPopulations[j+1]= orderingPopulations[j];
                    j = j-1;
                }
                fitnessArray[j+1] = temp;
                orderingPopulations[j+1] = tempOrd;
            }
        
        return fitnessArray;
    }
    
   int[][] performCrossover(int[][] orderingPopulations){
       
       Random rand = new Random(); 
       int randInt1 = rand.nextInt(popSize);
       int randInt2 = rand.nextInt(popSize);
       while(markedOrderings[randInt1]==true){
           randInt1 = rand.nextInt(popSize);
       }
       while(markedOrderings[randInt2]==true){
           randInt2 = rand.nextInt(popSize);
       }
       int cp = rand.nextInt(totalModuleNum);
       if(cp==totalModuleNum){
           cp -=1;
       }else if(cp==0){
           cp+=1;
           
       }
       
       int[] ordering1 = orderingPopulations[randInt1];
       int[] ordering2 = orderingPopulations[randInt2];
     
       /*
       System.out.println("cp = "+ cp);
       
       System.out.println("Ordering 1: ");
       for(int i = 0; i<totalModuleNum; i++){
           System.out.print(ordering1[i]+ " ");
       }
       System.out.println(" ");
       System.out.println("Ordering 2: ");
       for(int i = 0; i<totalModuleNum; i++){
           System.out.print(ordering2[i]+ " ");
       }
       */
       int[][] temp = new int[2][totalModuleNum];
       
       
       for(int i= 0; i<cp; i++){
           temp[0][i]=ordering1[i];
           temp[1][i]=ordering2[i];
       }
       for(int i=cp; i<totalModuleNum; i++){
           temp[0][i]=ordering2[i];
           temp[1][i]=ordering1[i];
       }
       
       /*
       System.out.println(" ");
        System.out.println("After crossover before changes ");
        System.out.println("Ordering 1: ");
       for(int i = 0; i<totalModuleNum; i++){
           System.out.print(temp[0][i] + " ");
       }
       System.out.println(" ");
       System.out.println("Ordering 2: ");
       for(int i = 0; i<totalModuleNum; i++){
           System.out.print(temp[1][i]+ " ");
       }
         System.out.println(" ");
           System.out.println(" ");
       
       */
       
       int total= totalModuleNum-1;
        for(int i=0; i<temp.length;i++){
            boolean sameFlag =true;
            while(sameFlag==true){
                int sameCount=0;
                for(int k = 0; k<totalModuleNum; k++){
                    for(int l = total; l>k; l--){
                         if(temp[i][k]==temp[i][l]&&(k!=l)){
                        sameCount ++;
                        temp[i][k]= rand.nextInt(totalModuleNum)+1;
                        }
                    }
                }
                 if(sameCount<1){
                    sameFlag = false;
                }else if(sameCount>0){
                    sameFlag = true;                  
                }
            }   
        }
        
        /*
        System.out.println(" ");
        System.out.println("After crossover ");
        System.out.println("Ordering 1: ");
       for(int i = 0; i<totalModuleNum; i++){
           System.out.print(temp[0][i] + " ");
       }
       System.out.println(" ");
       System.out.println("Ordering 2: ");
       for(int i = 0; i<totalModuleNum; i++){
           System.out.print(temp[1][i]+ " ");
       }
         System.out.println(" ");
           System.out.println(" ");
        */
        orderingPopulations[randInt1]= temp[0];
        orderingPopulations[randInt2] = temp[1];
        
       /* System.out.println("crossover");
        System.out.println("first index = "+ randInt1);
        System.out.println("second index = "+ randInt2);*/
        markedOrderings[randInt1]=true;
        markedOrderings[randInt2]=true;
        GACount +=2;
       return orderingPopulations;
   }
   
   int [][] performMutation(int [][] orderingPopulations){
       
        Random rand = new Random(); 
       int randInt1 = rand.nextInt(popSize);
       while(markedOrderings[randInt1]==true){
           randInt1 = rand.nextInt(popSize);
       }
       int randInt2 = rand.nextInt(totalModuleNum);
       int randInt3 = rand.nextInt(totalModuleNum);
       
       boolean sameFlag = true;
       while(sameFlag == true){
           if(randInt2==randInt3){
               randInt3=rand.nextInt(totalModuleNum);
           }else{
               sameFlag=false;
           }
       }
       
       int[] ordering = orderingPopulations[randInt1];
       
       int val1 = ordering[randInt2];
       int val2 = ordering[randInt3];
       
        ordering[randInt2]=val2;
        ordering[randInt3]=val1;
       
       orderingPopulations[randInt1]=ordering;
       
        /*System.out.println("mutation");
        System.out.println("index = "+ randInt1);*/
        
        markedOrderings[randInt1]=true;
        GACount ++;
        return orderingPopulations;
   }
    
   int[][]performReproduction(int[][]orderingPopulations){
       
       //System.out.println("reproduction");
       
       GACount++;
       
       return orderingPopulations;
   }
   
   int findBestOrdering(int [] fitnessArray){

       int bestLoc =0;
       for(int i = 0; i<fitnessArray.length; i++){
           int current = i;
           if(fitnessArray[i]<fitnessArray[bestLoc]){
               bestLoc = i;
           }
           
       }

       return bestLoc;
   }
   
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel courseModNumLbl;
    private javax.swing.JTextField courseModNumTxt;
    private javax.swing.JLabel crossoverProbLbl;
    private javax.swing.JTextField crossoverProbTxt;
    private javax.swing.JLabel examSessionsLbl;
    private javax.swing.JTextField examSessionsTxt;
    private javax.swing.JLabel genLabel;
    private javax.swing.JTextField genTxt;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JLabel mutationProbLbl;
    private javax.swing.JTextField mutationProbTxt;
    private javax.swing.JButton okBtn;
    private javax.swing.JLabel popLbl;
    private javax.swing.JTextField popTxt;
    private javax.swing.JLabel reproductionProbLbl;
    private javax.swing.JTextField reproductionProbTxt;
    private javax.swing.JLabel studentNumLbl;
    private javax.swing.JTextField studentNumTxt;
    private javax.swing.JLabel titleLbl;
    private javax.swing.JLabel totalModNumLbl;
    private javax.swing.JTextField totalModNumTxt;
    private javax.swing.JLabel warningLbl;
    private javax.swing.JLabel warningLbl2;
    // End of variables declaration//GEN-END:variables
}
